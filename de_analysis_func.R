de_analysis <-
  function(data,
           sample_vec,
           cpm_fil = NULL,
           de_p.val = 1,
           export = FALSE,
           summary = FALSE) {
    #Detect what data type is provided
    if (class(data)[1] == "DGEList") {
      bcop_dgelist <- dgelist
    } else if (class(data) == "list" &
               all(names(data) == c("counts", "annotation", "targets", "stat"))) {
      bcop_dgelist <- featureCounts2DGEList(data)
    } else {
      stop("The given data is not a counts object returned by Rsubread or a DGEList")
    }
    
    #Determines if cpm filtering is requested and normalizes the count data
    if (is.null(cpm_fil) == FALSE & is.numeric(cpm_fil) == TRUE) {
      counts_per_mil <- cpm(bcop_dgelist) > cpm_fil
      kept_genes <- which(rowSums(counts_per_mil) >= 1)
      filtered_dgelist <- bcop_dgelist[kept_genes, ]
      normalized_dgelist <-
        normLibSizes(bcop_dgelist, method = "TMM")
    } else if (is.null(cpm_fil) == TRUE) {
      normalized_dgelist <- normLibSizes(bcop_dgelist, method = "TMM")
    } else {
      stop("cpm_fill must be a numeric to set a cpm minimum or NULL to not filter")
    }
    
    #Determine number of genes in total
    num_of_gene <- length(normalized_dgelist$genes$Chr)
    
    #Create model matrix from provided sample info vector
    if (is.vector(sample_vec) == TRUE &
        length(sample_vec) == length(bcop_dgelist$samples$group)) {
      sample_model_matrix <- model.matrix( ~ sample_vec)
    } else {
      stop("sample_vec must be a vector with the same length as the number of samples")
    }
    
    #Calculate dispersions
    normalized_dgelist <- estimateGLMCommonDisp(normalized_dgelist,
                                                design = sample_model_matrix)
    normalized_dgelist <- estimateGLMTrendedDisp(normalized_dgelist,
                                                 design = sample_model_matrix)
    normalized_dgelist <- estimateGLMTagwiseDisp(normalized_dgelist,
                                                 design = sample_model_matrix)
    #Fit model
    glm_fitted_model <-
      glmFit(normalized_dgelist, sample_model_matrix)
    
    #Calculate lrt
    likelihood_ratio_test <- glmLRT(glm_fitted_model)
    
    #Calculate resulting de genes
    results <-
      topTags(likelihood_ratio_test, n = num_of_gene, p.value = de_p.val)
    if (export == TRUE) {
      results_export <- rownames_to_column(results$table, "gene_id")
      return(results_export)
    } else if (summary == TRUE) {
      deGenes <- decideTests(likelihood_ratio_test, p.value = de_p.val)
      deGenes_summary <- table(deGenes)
      return(deGenes_summary)
    } else {
      return(results)
    }
  }

go_analysis <-
  function(txdb,
           de_results,
           go_assignments,
           logFC_cutoff = 0,
           go_p.val = 0.05) {
    
    #Verify inputs are correct types
    if (class(de_results)[1] != "TopTags") {
      stop("de_results must be a TopTags object generated by edgeR")
    }
    if (class(txdb)[1] != "TxDb") {
      stop("txdb must be a TxDb object from GenomicFeatures")
    }
    if (class(go_assign_vec)[1] != "vctrs_list_of") {
      stop("go_assignments must be a vector")
    } else if (str_starts(go_assign_vec[[1]][1], "GO:", negate = TRUE)) {
      warning("The go_assignments vector doesn't appear to have go assignments!")
    }
    if (is.numeric(logFC_cutoff) == FALSE) {
      stop("logFC_cutoff is not numeric!")
    }
    if (is.numeric(go_p.val) ==FALSE) {
      stop("go_p.val is not numeric!")
    }  else if (!(go_p.val >= 0 & go_p.val <= 1)) {
      stop("go_p.val must be between 0 and 1")
    }
    
    #Filter genes to ones meeting logFC_cutoff
    if (logFC_cutoff > 0) {
      genes_for_annotation <-
        as.integer(de_results$table$logFC > logFC_cutoff)
      genes_names_for_annotation <- row.names(de_results$table) |>
        str_remove_all("gene-")
      names(genes_for_annotation) <- genes_names_for_annotation
    } else if (logFC_cutoff < 0) {
      genes_for_annotation <-
        as.integer(de_results$table$logFC < logFC_cutoff)
      genes_names_for_annotation <- row.names(de_results$table) |>
        str_remove_all("gene-")
      names(genes_for_annotation) <- genes_names_for_annotation
    } else {
      genes_for_annotation <-
        as.integer(p.adjust(de_results$table$PValue[de_results$table$logFC != 0],
                            method = "BH") < go_p.val)
      genes_names_for_annotation <-
        row.names(de_results$table[de_results$table$logFC != 0,]) |>
        str_remove_all("gene-")
      names(genes_for_annotation) <- genes_names_for_annotation
    }
    
    #Calculate transcript lengths
    txs_by_gene <- transcriptsBy(txdb, "gene")
    txs_by_gene <-
      txs_by_gene[names(txs_by_gene) %in% genes_names_for_annotation, ]
    txs_length <- median(width(txs_by_gene))
    
    #Calculate pwf
    calculated_pwf <-
      nullp(genes_for_annotation,
            "Bradysia coprophila",
            "knownGene",
            txs_length)
    go_results <-
      goseq(calculated_pwf,
            "Bradysia coprophila",
            "knownGene",
            go_assignments)
    return(go_results)
  }