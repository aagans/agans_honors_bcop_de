de_analysis <-
  function(data,
           sample_vec,
           cpm_fil = NULL,
           de_p.val = 1,
           export = FALSE,
           summary = FALSE) {
    #Detect what data type is provided
    if (class(data)[1] == "DGEList") {
      bcop_dgelist <- dgelist
    } else if (class(data) == "list" &
               all(names(data) == c("counts", "annotation", "targets", "stat"))) {
      bcop_dgelist <- featureCounts2DGEList(data)
    } else {
      stop("The given data is not a counts object returned by Rsubread or a DGEList")
    }
    
    #Determines if cpm filtering is requested and normalizes the count data
    if (is.null(cpm_fil) == FALSE & is.numeric(cpm_fil) == TRUE) {
      counts_per_mil <- cpm(bcop_dgelist) > cpm_fil
      kept_genes <- which(rowSums(counts_per_mil) >= 1)
      filtered_dgelist <- bcop_dgelist[kept_genes,]
      normalized_dgelist <- normLibSizes(bcop_dgelist, method = "TMM")
    } else if (is.null(cpm_fil) == TRUE) {
      normalized_dgelist <- normLibSizes(bcop_dgelist, method = "TMM")
    } else {
      stop("cpm_fill must be a numeric to set a cpm minimum or NULL to not filter")
    }
    
    #Determine number of genes in total
    num_of_gene <- length(normalized_dgelist$genes$Chr)

    #Create model matrix from provided sample info vector
    if (is.vector(sample_vec) == TRUE &
        length(sample_vec) == length(bcop_dgelist$samples$group)) {
      sample_model_matrix <- model.matrix(~ sample_vec)
    } else {
      stop("sample_vec must be a vector with the same length as the number of samples")
    }
    
    #Calculate dispersions
    normalized_dgelist <- estimateGLMCommonDisp(normalized_dgelist,
                                                design = sample_model_matrix)
    normalized_dgelist <- estimateGLMTrendedDisp(normalized_dgelist,
                                                 design = sample_model_matrix)
    normalized_dgelist <- estimateGLMTagwiseDisp(normalized_dgelist,
                                                 design = sample_model_matrix)
    #Fit model
    glm_fitted_model <-
      glmFit(normalized_dgelist, sample_model_matrix)
    
    #Calculate lrt
    likelihood_ratio_test <- glmLRT(glm_fitted_model)
    
    #Calculate resulting de genes
    results <-
      topTags(likelihood_ratio_test, n = num_of_gene, p.value = de_p.val)
    if (export == TRUE) {
      results_export <- rownames_to_column(results$table, "gene_id")
      return(results_export)
    } else if (summary == TRUE) {
      deGenes <- decideTests(likelihood_ratio_test, p.value = de_p.val)
      deGenes_summary <- table(deGenes)
      return(deGenes_summary)
    } else {
      return(results)
    }
  }

go_analysis <- function(txdb, de_results, go_assignments, logFC_cutoff = 0, go_p.val = 0.05) {
  if (class(de_results)[1] != "TopTags") {
    stop("de_results must be a TopTags object generated by edgeR")
  }
  
  if (logFC_cutoff > 0) {
    genes_for_annotation <- as.integer(de_results$table$logFC > logFC_cutoff)
    genes_names_for_annotation <- row.names(de_results$table) |> 
      str_remove_all("gene-")
    names(genes_for_annotation) <- genes_names_for_annotation
  } else if (logFC_cutoff < 0) {
    genes_for_annotation <- as.integer(de_results$table$logFC < logFC_cutoff)
    genes_names_for_annotation <- row.names(de_results$table) |> 
      str_remove_all("gene-")
    names(genes_for_annotation) <- genes_names_for_annotation
  } else {
    genes_for_annotation <- as.integer(p.adjust(de_results$table$PValue[de_results$table$logFC != 0], 
                                 method = "BH") < go_p.val)
    genes_names_for_annotation <- row.names(de_results$table[de_results$table$logFC != 0, ]) |> 
      str_remove_all("gene-")
    names(genes_for_annotation) <- genes_names_for_annotation
  }
  
  txs_by_gene <- transcriptsBy(txdb, "gene")
  txs_by_gene <- txs_by_gene[names(txs_by_gene) %in% genes_names_for_annotation,]
  txs_length <- median(width(txs_by_gene))
  
  calculated_pwf <- nullp(genes_for_annotation, "Bradysia coprophila", "knownGene", txs_length)
  go_results <- goseq(calculated_pwf, "Bradysia coprophila", "knownGene", go_assignments)
  return(go_results)
}
